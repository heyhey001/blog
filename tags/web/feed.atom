<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">Armin Ronacher's Thoughts and Writings</title>
  <id>http://lucumr.pocoo.org/feed.atom</id>
  <updated>2012-08-05T00:00:00Z</updated>
  <link href="http://lucumr.pocoo.org/" />
  <link href="http://lucumr.pocoo.org/feed.atom" rel="self" />
  <subtitle type="text">Armin Ronacher's personal blog about programming, games and random thoughts that come to his mind.</subtitle>
  <generator>Werkzeug</generator>
  <entry xml:base="http://lucumr.pocoo.org/feed.atom">
    <title type="text">Battlelog: Modern Web Applications are Here</title>
    <id>http://lucumr.pocoo.org/2011/11/15/modern-web-applications-are-here</id>
    <updated>2011-11-15T00:00:00Z</updated>
    <link href="http://lucumr.pocoo.org/2011/11/15/modern-web-applications-are-here" />
    <author>
      <name>Armin Ronacher</name>
    </author>
    <content type="html">&lt;p&gt;It's the shooter season of the year and this fall was all about Modern
Warfare 3 versus Battlefield 3.  And being the kind of game they are they
also try to keep their audience playing by introducing some additional
level of engagement.  Both Call of Duty and Battlefield introduced their
own online community websites and statistic platforms.  Call of Duty has
Elite, Battlefield has Battlelog.&lt;/p&gt;
&lt;p&gt;But just because these services are sitting in the same spot it does not
mean they are in any way similar.  And that actually goes for more than
just their monetization plans and feature sets.  Elite is a traditional
application as traditional as it can be.  You sign up, there is Flash,
there is a bit of JavaScript, there are tons of requests for each page and
a playercard transmits about 3 MB of data to your client.  Not very
interesting to say the least.&lt;/p&gt;
&lt;p&gt;But what are they doing?  Notwithstanding some of their respective extra
features both Battlelog and Elite are essentially a social network for
shooter games that expose the statistics of your individual gameplay as
well as the one of your friends to you.  Everything you do in the game is
reflected on these websites and you can further interact with the game
there by commenting on gameplay and chatting up with friends.&lt;/p&gt;
&lt;p&gt;Elite by itself is not very interesting technology wise, however Battlelog
certainly is.  It shows that an application that is probably used by
millions of gamers can be built on modern web technology as well.  And
under the hood is one of the most interesting ways to built a modern web
application that I think you should check out.&lt;/p&gt;
&lt;div class=&quot;section&quot; id=&quot;embrace-the-client&quot;&gt;
&lt;h2&gt;Embrace the Client&lt;/h2&gt;
&lt;p&gt;A few months back I was claiming that WSGI is not the place for pluggable
applications and that it would make sense &lt;a class=&quot;reference external&quot; href=&quot;/2011/7/27/the-pluggable-pipedream/&quot;&gt;to assemble applications on the
client-side&lt;/a&gt;.  Turns out, Battlelog
is doing just that.  While I do not know what all of their infrastructure
looks like, their network graph and license information on the page is
revealing.&lt;/p&gt;
&lt;p&gt;Battlelog is written by a company called &lt;a class=&quot;reference external&quot; href=&quot;http://esn.me/&quot;&gt;ESN&lt;/a&gt; and their
infrastructure from the released code is basically Python 2.x with
gevent as well as JavaScript with jQuery and their own stuff on the client
and Java for their websocket backend.&lt;/p&gt;
&lt;p&gt;If you send an HTTP request to the website it appears to work as if it was
a regular website.  You get a bunch of HTML rendered and nothing
interesting happens.  However if you click on any link you do not get HTML
transmitted.  Instead what is transmitted is JSON, the HTML5 history API
is used to modify the URL dynamically and all the HTML is rendered on the
client.  Since it appears to be able to do both we can compare the sizes
of the data transmitted easily.&lt;/p&gt;
&lt;p&gt;The HTML for the index page is 18KB in size.  If we trigger the request to
the same URL with just the JSON it's 4KB.  Not only is it less to
transmit, it also means that the server is essentially just generating
JSON instead of rendering whole templates which also means a performance
improvement for the client.&lt;/p&gt;
&lt;p&gt;The platform is a work of beauty in general and I am amazed how little I
have heard on the interwebs about it.  So to give you an idea why it's an
incredible technical achievement on so many levels, here the breakdown.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;feature-overview&quot;&gt;
&lt;h2&gt;Feature Overview&lt;/h2&gt;
&lt;p&gt;To understand what Battlelog is here a brief overview of what it does.
These are not necessarily the features that are immediately obvious to the
user but are very obvious for the interested developer that wants to peak
under the hood:&lt;/p&gt;
&lt;ul class=&quot;simple&quot;&gt;
&lt;li&gt;the website insta-updates based on information coming from the push
connection.  If you have the website open in the background you can
hear a notification sound being played just the second your game ends.
That notification sound is for the report generated from the round you
played.&lt;/li&gt;
&lt;li&gt;The same websocket connection for the website is also used for the
chat feature on the site as well as game invites and more.&lt;/li&gt;
&lt;li&gt;All the pages can be rendered on both the client side via JavaScript
as well as the server.  How this work I cannot tell you but I find it
interesting considering the server side is Python.  So their templates
compile to Python and JavaScript as it seems.&lt;/li&gt;
&lt;li&gt;Battlelog comes with an optional browser plugin that makes it possible
to join into a game on the PC version of Battlefield right from within
the browser.  This plugin can interact with the game and exposes some
other functionality that is lacking in HTML5 (such as issuing pings).&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;how-the-client-operates&quot;&gt;
&lt;h2&gt;How the Client Operates&lt;/h2&gt;
&lt;p&gt;In order to understand why Battlelog is interesting engineering we have to
reconstruct what it appears to be doing.  Again, I am not claiming
knowledge of their server technology, I basically just observed what I saw
and concluded a few things from it.&lt;/p&gt;
&lt;p&gt;When you access a page you get some nicely rendered HTML back.  One of the
things that is also transmitted to you is a large JavaScript document that
contains their client side framework as well as the rendering instructions
for all pages compiled to JavaScript code.  The framework then hooks into
your browser's navigation code an intercepts all page loads.  Instead of
letting the browser replace the page with something new on load it instead
does the HTTP request via Ajax and adds an additional header to the HTTP
request: &lt;cite&gt;X-Ajax-Navigation&lt;/cite&gt;.  If the server side sees that header it will
instead of rendering to HTML deliver the data that is normally passed to
the template as JSON.&lt;/p&gt;
&lt;p&gt;The data you get back is everything the page needs to render, including
the name of the template.  When that data arrives on the client the
browser replaces the current page content with the data that was rendered
on the client side from the received JSON.  Not only that, it also makes
sure to use the HTML5 history API to change the browser URL.&lt;/p&gt;
&lt;p&gt;The user does not notice that anything interesting is going on unless he's
tech savvy enough to open the firebug network panel and watch the system
operate.  In fact the whole thing is so incredible smooth that you would
not notice anything interesting besides the fact that the page loads fast.
I mean seriously fast.  Clicking on a link in Battlelog is such a snappy
operation it's haunting for the trained web developer eye.  Very few
systems respond this quickly.  This is especially noticeable on pages that
do not involve a lot of different data such as the news section of the
website or the forums.&lt;/p&gt;
&lt;p&gt;If you look at the website it also has a bar on the bottom of the screen
that shows notifications, your friendlist, open chat windows and a few
other things.  This bar can have state.  You can toggle windows open and
closed, you can scroll in the chat window, enter new next and the bar will
stay open and unchanged if you navigate to a different page.  True, this
is nothing special these days, facebook does it too.  However from the
design that Battlelog follows this comes natural.  When the page contents
are hooked in the DOM element for that bar on the bottom is preserved and
not touched.&lt;/p&gt;
&lt;p&gt;The other aspect of Battlelog is the real time component with web sockets.
I have not looked too far into that but it appears that it's based on an
abstraction layer on top of web sockets, Flash or whatever is supported
that was written by ESN for other projects in mind as well.  The server
code sends an information to the push hub which handles the socket
connection for the clients.  This way various systems can inform the
client about updates, that does not even have to be Battlelog itself.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;why-the-client&quot;&gt;
&lt;h2&gt;Why the Client?&lt;/h2&gt;
&lt;p&gt;While it's not necessarily the case with Battlelog, there are a bunch of
really good reasons why you want to render stuff on the client side:&lt;/p&gt;
&lt;ol class=&quot;arabic simple&quot;&gt;
&lt;li&gt;You can do partial updates.  And you want partial updates since they
are good for the user experience.&lt;/li&gt;
&lt;li&gt;You can mix content together from different resources which is good
for caching.  If there is information on the page that rarely changes
and is the same for each user you can load it from a well cached page
and keep it in the client's DOM and never replace it.&lt;/li&gt;
&lt;li&gt;Generating HTML on the server side is more expensive than on the
client.  You don't pay for the client side and even the fastest
template engine on the server is beaten by an optimized JSON
serializer.  Faster apps mean more satisfied customers.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Even if you do not have a JavaScript heavy application, moving
computations to the client side is a good thing.  This obviously assumes
that it does not break the navigation like some websites do.  Battlelog
does not do that.  The principles on which Battlelog is built would also
very well work in a more traditional application.  However it requires a
well structured architecture were the data you're sending to the template
engine is simple (and secure!) enough that you can put it in JSON and that
the templates themselves are simple enough that compiling them to
JavaScript is an option.&lt;/p&gt;
&lt;p&gt;Jinja2 for instance could in theory execute on the client but practically
not.  Practically it's exposing a little bit too much of Python to make
sense to compile to JavaScript.  But a template language much like Jinja2
could be written that would make this possible.&lt;/p&gt;
&lt;p&gt;In fact I think you could build a microframework that would very well
support this paradigm and still be agnostic to the JavaScript code you're
running on the client for the most part.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;the-native-code-thing&quot;&gt;
&lt;h2&gt;The Native Code Thing&lt;/h2&gt;
&lt;p&gt;The real interesting thing about Battlelog however is a Windows PC
specific component.  If you are heading to Battlelog from a Windows PC and
you own the PC version of Battlefield 3 you can launch into a game right
from within the browser.  How does this work?  It works with the help of a
browser plugin that exposes additional functionality to the in browser
client.  Namely it has a function to start the game and pass it
information as well as a general purpose function to ping an IP address
which is used for the server browser.&lt;/p&gt;
&lt;p&gt;In fact if you are playing on PC this is how the game is launched, always.
There is no in game menu, you join from within your browser.  This is mind
blowing thing.  First of all it makes it easier for DICE to update the
server infrastructure since it's now mostly separated from the client and
also makes for much quicker iterations.&lt;/p&gt;
&lt;p&gt;The communication for the most part works in one-way but in a cycle as it
seems.  If you log into Battlelog and head to the server browser you get a
list of servers.  How does &lt;em&gt;that&lt;/em&gt; work?  Here's how:&lt;/p&gt;
&lt;ol class=&quot;arabic simple&quot;&gt;
&lt;li&gt;When you send an HTTP request to Battlelog it determines your
approximate location based on the request IP.  This way it can
pre-filter servers for you that are probably near you.&lt;/li&gt;
&lt;li&gt;Each server connects to a ping site on connect.  There are a couple
different ping sites for different countries.  The USA have three I
think, Europe has one, Japan has one, Australia etc.  Each ping site
then notifies Battlelog about the distance of that server to the ping
site.&lt;/li&gt;
&lt;li&gt;Based on that information as well as your filter settings, Battlelog
now sends you a list of servers.  Once that data is retrieved by the
client it starts connecting to the browser plugin and asks it to ping
all the server IPs it received.&lt;/li&gt;
&lt;li&gt;If you now want to join that server it sends an HTTP request to
the Battlelog server side to reserve a slot on that server.  In
response it gets a token that identifies that slot.  When the server
managed to reserve a slot for that player the client uses the
serverlog plugin to boot up the game.  It passes that token to the
game alongside a secret and lets the game boot in the background.&lt;/li&gt;
&lt;li&gt;While the game is booting up it uses the received authentication
information to use the slot that was reserved.  When it loaded up
properly it notifies the Battlelog client with the help of the plugin
about changes in the executable.&lt;/li&gt;
&lt;li&gt;The plugin also exposes some more functionality of the client to the
website which makes it possible for the JavaScript part of Battlelog
to close the game away and initiate some other game modes such as coop
hosting.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;thinking-does-it-need-the-plugin&quot;&gt;
&lt;h2&gt;Thinking: Does it need the Plugin?&lt;/h2&gt;
&lt;p&gt;Now here was me thinking.  Would the plugin be necessary to accomplish all
of the above things or could it be done in a different way?  Native
applications are here to stay, that's a given.  However more and more
stuff of what a native application does can be moved into a browser for
great success.  So how does a web application speak to a native
application?&lt;/p&gt;
&lt;p&gt;The traditional way is by letting the application register a custom URL
scheme and then letting the user click on that link which then launches
the application.  That's unfortunately a one way communication only.  But
that might be everything that is needed.&lt;/p&gt;
&lt;p&gt;So here is how it could be done.  Battlefield or any other application
that wants to do the same but without the browser plugin could instead
register a URL handler with a unique name.  Let's say &lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;battlefield3://&lt;/span&gt;&lt;/tt&gt;.
The operating system then knows about this URL scheme and can start a
handling application.  What can we do with this?&lt;/p&gt;
&lt;p&gt;The server component would have to uniquely identify a user for starters.
Considering that each user has to log in that's fine anyways.  Then next
to that user information one would have to remember if the game is
running and how.  What does that mean?  Let's start with the simple case:
the game is not running.  The Battlelog server looks at the current user
and sees he or she does not have the game running.  Consequently it will
generate a unique token and generate a URL to the URL scheme (for instance
&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;battlefield3://start?token=...&lt;/span&gt;&lt;/tt&gt;.  It then generates a JavaScript prompt
that informs the user that he has to launch the game by clicking on the
link generated.  This is the only chance in flow that is necessary.  By
clicking that link the user agrees that he wants to start that
application.&lt;/p&gt;
&lt;p&gt;But instead of launching the game it starts a daemon.  That daemon takes
the token and picks a random TCP port on the system and starts an HTTP
server there.  Once that server is running it notifies the central server
that it's running and on what port.  Since the web browser has a push
notification channel open it will get a notification now that the daemon
is running and on which port.&lt;/p&gt;
&lt;p&gt;After that it can use HTTP and JSONP to communicate with the daemon.  But
how does the daemon know when to shut down?  Basically that daemon will
needs to be informed when to shut down.  I would assume that 15 minutes
without a ping from the browser would be a good indication that it should
destruct itself.  When shutting down it also tells Battlelog that it's no
longer running to clear out the port entry.&lt;/p&gt;
&lt;p&gt;Additionally to make this better it should not only record the port but
also an identifier that uniquely identifies the machine the daemon is
running on so that the user can alternate between different computers
without ending up with weird behavior where the central server is
informing the browser that the game is running when in fact it's running
on a different machine.&lt;/p&gt;
&lt;p&gt;Since Battlefield 3 supports only one running game per user account it
does not make sense to support more than one session.  If that would be
wanted it could obviously be done.&lt;/p&gt;
&lt;p&gt;The downside here obviously is that it needs a websocket connection and a
central server that acts as mediator between the different systems
(daemon, client side app).  In Battlefield 3's case that would not be a
concern (and already is not) since it's an online game.  The second
problem here is that it needs one additional user interaction: the user
has to click on the link to activate it.  This currently is not necessary
in Battlelog since it's provided by a plugin.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;browser-native-code-communication&quot;&gt;
&lt;h2&gt;Browser &amp;lt;-&amp;gt; Native Code Communication&lt;/h2&gt;
&lt;p&gt;The whole concept of using a browser application as a frontend for a
native application is an interesting thing indeed.  Due to offline support
becoming widespread that is also no longer a concern if the application
can largely run in the client side.  But that would break my above
hypothetical example of interacting with a local application.&lt;/p&gt;
&lt;p&gt;Falling back to a browser plugin currently is the only way to make a
consenting communication with a local application.  I really wonder if
there is not room for improvement by having an API in HTML5 that makes
this possible which would also work for offline applications.&lt;/p&gt;
&lt;p&gt;Basically what would be needed is a simple way for a two way communication
with a local application.  That application would have to register itself
somewhere and then be able to respond to the client's requests.  It could
totally work like a CGI script (eg: speak HTTP via stdin/stdout).&lt;/p&gt;
&lt;p&gt;I think there is a lot of potential for such applications in the future
and Battlelog shows that it can be done already with a little help of a
small plugin.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;killer-applications&quot;&gt;
&lt;h2&gt;Killer Applications&lt;/h2&gt;
&lt;p&gt;One last thing.  Battlefield 3 sold a couple millions of copies.  The PC
users all have to update to recent version of their browsers since the
website basically demands a modern browser.  Even with all the fallbacks
in place, it kinda forces people to update.  For a certain audience
websites like Battlelog can be the killer application of modern HTML5
features.  Keep this in mind.  In case you have a similar audience that's
something to take advantage of.&lt;/p&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry xml:base="http://lucumr.pocoo.org/feed.atom">
    <title type="text">Common Mistakes as Python Web Developer</title>
    <id>http://lucumr.pocoo.org/2010/12/24/common-mistakes-as-web-developer</id>
    <updated>2010-12-24T00:00:00Z</updated>
    <link href="http://lucumr.pocoo.org/2010/12/24/common-mistakes-as-web-developer" />
    <author>
      <name>Armin Ronacher</name>
    </author>
    <content type="html">&lt;p&gt;A few weeks ago I had a heated discussion with a bunch of Python and Open
Source people at a local meet-up about the way Python's path joining works.
I was always pretty sure that people are aware of how the path joining
works and why it works that way.  However a bit of searching around on the
internet quickly showed that it's actually a pretty common mistake to use
the &lt;cite&gt;os.path.join&lt;/cite&gt; function with arbitrary and unfiltered input, leading
to security issues.  Because the most common case where user input comes
from another system is web development I went a bit further and tried to
find a few other cases where people might be blindly trusting an API or
operating system.&lt;/p&gt;
&lt;p&gt;So here it is: my list of things not to do when doing Python web
development.&lt;/p&gt;
&lt;div class=&quot;section&quot; id=&quot;untrusted-data-and-file-systems&quot;&gt;
&lt;h2&gt;Untrusted Data and File Systems&lt;/h2&gt;
&lt;p&gt;Unless you are running on a virtualized filesystem like when you are
executing code on Google Appengine, chances are, vital files can be
accessed with the rights your application has.  Very few deployments
actually reduce the rights of the executing user account to a level where
it would become save to blindly trust user submitted filenames.  Because
it typically isn't, you have to think about that.&lt;/p&gt;
&lt;p&gt;In PHP land this is common knowledge by now because many people write
innocent looking code like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?php&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;header.php&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$page&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;isset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$_GET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;page&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$_GET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;page&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;index&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$filename&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$page&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;.php&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;file_exists&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;missing_page.php&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&amp;quot;footer.php&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now the problem is that if you accept the filename blindly one could
just pass a string with some leading “go one layer up” markers and access
files somewhere else on the file system.  Now many people thought that
wouldn't be a problem because the file has to end with “.php” so only PHP
files can be accessed.  Turns out that PHP never (at least not until
recently) removed nullbytes from the string before opening the file.  Thus
the underlying C function that opened the file stopped reading at the null
byte.  So if one attacker would access the page
&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;?page=../../../../htpasswd%00&lt;/span&gt;&lt;/tt&gt; he would see the contents of the passwd
file.&lt;/p&gt;
&lt;p&gt;Python programmers apparently don't care too much about this problem
because Python's file opening functions don't have this problem and
reading files from the filesystem is a very uncommon thing to do anyways.
However in the few situations where people do work with the filenames,
always always will you find code like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;upload_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;destination_file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UPLOAD_FOLDER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;destination_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;wb&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;copy_fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The problem there is that you expect &lt;cite&gt;os.path.join&lt;/cite&gt; never to go a folder
up.  While in fact, that's exactly what &lt;cite&gt;os.path.join&lt;/cite&gt; is capable of
doing:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;os&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;/var/www/uploads&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;../foo&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;go&quot;&gt;&amp;#39;/var/www/uploads/../foo&amp;#39;&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;/var/www/uploads&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;/foo&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;go&quot;&gt;&amp;#39;/foo&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While in this case the attacker is “just” able to overwrite files anywhere
on the filesystem where the user has access (might be able to override
your code and inject code that way!) it's not uncommon to read files on
the filesystem as well and expose information that way.&lt;/p&gt;
&lt;p&gt;So yes, &lt;cite&gt;os.path.join&lt;/cite&gt; is totally not safe to use in a web context.
Various libraries have ways that help you deal with this problem.
Werkzeug for instance has a function called &lt;cite&gt;secure_filename&lt;/cite&gt; that will
strip any path separators from the file, slashes, even remove non-ASCII
characters from the path as character sets and filesystems are immensly
tricky.  At the very least you should do this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;re&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;_split&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;re&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;[\0&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;]&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;re&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;escape&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;altsep&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])))&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;secure_filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_split&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sub&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This will remove any slashes and null bytes from the filename.  Why also
remove the Null byte if Python does not have a problem with that?  Because
Python might not, but your code.  A nullbyte in the filename will trigger
a &lt;cite&gt;TypeError&lt;/cite&gt; which very few people are expecting:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\0&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;gt&quot;&gt;Traceback (most recent call last):&lt;/span&gt;
  File &lt;span class=&quot;nb&quot;&gt;&amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;&lt;/span&gt;, line &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;, in &lt;span class=&quot;n&quot;&gt;&amp;lt;module&amp;gt;&lt;/span&gt;
&lt;span class=&quot;gr&quot;&gt;TypeError&lt;/span&gt;: &lt;span class=&quot;n&quot;&gt;file() argument 1 must be encoded string without NULL bytes, not str&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;On Windows you furthermore have to make sure people are not naming their
files after device files, but that is outside of the scope of this post.
If you are curious, check how Werkzeug does it.&lt;/p&gt;
&lt;p&gt;If you actually do want to allow slashes in the filename there are a
couple of things you have to consider.  On POSIX the whole system is
incredible easy: if it starts with a trailing slash or the combination of
&lt;tt class=&quot;docutils literal&quot;&gt;../&lt;/tt&gt; it will or might try to reference a file outside of the folder you
want the file to be in.  That's easy to prevent:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;posixpath&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;is_secure_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;posixpath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;normpath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;startswith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;../&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;On windows the whole situation is more tricky (and I fell into that trap a
few days ago as well).  First of all you have backslashes you have to
consider.  Technically you would also have to consider colons on Mac OS,
but there are very few people that still aim for Mac OS compatibility.
Thus the backslash is the main culprit.  Secondly you can't just test for
absolute paths by checking if the path starts with a slash.  On windows
there are multiple different kinds of absolute paths: regular Unix
absolute paths and secondly absolute paths that also include a drive
letter.  Thankfully the path module provides ways to reliably check if the
path is absolute.&lt;/p&gt;
&lt;p&gt;The following function checks if paths will not manage to escaped a
folder on POSIX and Windows:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;os&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;non_slash_sep&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sep&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sep&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;altsep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sep&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;is_in_folder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;normpath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sep&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;non_slash_seps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sep&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isabs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;startswith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;../&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The idea is that we consider the filenames to be in posix notation and
that the operating system is fine with filenames containing slashes.  That
is the case for all operating systems you would care about these days.
Then if the native operating system path separator is in the string we can
assume it's not a valid character for a filename on the web anyways and
consider it unsafe.  Once that passed we make sure the path is not
absolute or does not start with the special &lt;tt class=&quot;docutils literal&quot;&gt;../&lt;/tt&gt; string that indicates
going to a higher level on both Windows and POSIX.&lt;/p&gt;
&lt;p&gt;Generally speaking though, if you do aim for windows compatibility you
have to be extra careful because Windows has its special device files in
every folder on the filesystem for DOS compatibility.  Writing to those
might be problematic and could be abused for denial of service attacks.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;mixing-up-data-with-markup&quot;&gt;
&lt;h2&gt;Mixing up Data with Markup&lt;/h2&gt;
&lt;p&gt;This is a topic that always makes me cringe inside.  I know it's very
common and many don't see the issue with it but it's the root of a whole
bunch of problems and unmaintainable code.  Let's say you have some data.
That data for all practical purposes will be a string of some arbitrary
maximum length and that string will be of a certain format.  Let's say
it's prosaic text and we want to preserve newlines but collapse all other
whitespace to a single space.&lt;/p&gt;
&lt;p&gt;A very common pattern.&lt;/p&gt;
&lt;p&gt;However that data is usually displayed on a website in the context of
HTML, so someone will surely bring up the great idea to escape the input
text and convert newlines to &lt;tt class=&quot;docutils literal&quot;&gt;&amp;lt;br&amp;gt;&lt;/tt&gt; before feeding the data into the
database.  Don't do this!&lt;/p&gt;
&lt;p&gt;There are a bunch of reasons for this but the most important one is called
“context”.  Web applications these days are getting more and more complex,
mainly due to the concept of APIs.  A lot of the functionality of the
website that was previously only avaiable in an HTML form is now also
available as RESTful interfaces speaking some other format such as JSON.&lt;/p&gt;
&lt;p&gt;The context of a rendered text in your web application will most likely be
“HTML”.  In that context, &lt;tt class=&quot;docutils literal&quot;&gt;&amp;lt;br&amp;gt;&lt;/tt&gt; makes a lot of sense.  But what if your
transport format is JSON and the client on the other side is not
(directly) rendering into HTML?  This is the case for twitter clients for
instance.  Yet someone at Twitter decided that the string with the
application name that is attached to each tweet should be in HTML.  When I
wrote my first JavaScript client for that API I was parsing that HTML with
jQuery and fetching the application name as a string because I was only
interested in that.  Annoying.  However even worse: someone found out a
while later that this particular field could actually be used to emit
arbitrary HTML.  &lt;a class=&quot;reference external&quot; href=&quot;http://praetorianprefect.com/archives/2010/06/persistent-xss-on-twitter-com/&quot;&gt;A major security disaster&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The other problem is if you have to reverse the stuff again.  If you want
to be able to edit that text again you would have to unescape it,
reproduce the original newlines etc.&lt;/p&gt;
&lt;p&gt;So there should be a very, very simple rule (and it's actually really
simple): store the data as it comes in.  Don't flip a single bit!  (The
only acceptable conversion before storing stuff in the database might be
Unicode normalization)&lt;/p&gt;
&lt;p&gt;When you have to display your stored information: provide a function that
does that for you.  If you fear that this could become a bottleneck:
memcache it or have a second column in your database with the rendered
information if you absolutely must.  But never, ever let the HTML
formatted version be the only thing you have in your database.  And
certainly never expose HTML strings over your API if all you want to do is
to transmit text.&lt;/p&gt;
&lt;p&gt;Every time I get a notification on my mobile phone from a certain
notification service where the message would contain an umlaut the
information arrives here completely broken.  Turns out that one service
assumes that HTML escaped information is to be transmitted, then however
the other service only allows a few HTML escaped characters and completely
freaks out when you substitute “ä” with “&amp;amp;auml;”.  If you ever are in the
situation where you have to think about “is this plain text that is HTML
escaped or just plain text” you are in deep troubles already.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;spending-too-much-time-with-the-choice-of-framework&quot;&gt;
&lt;h2&gt;Spending too much Time with the Choice of Framework&lt;/h2&gt;
&lt;p&gt;This should probably go to the top.  If you have a small application (say
less than 10.000 lines of code) the framework probably isn't your problem
anyways.  And if you have more code than that, it's still not that hard to
switch systems when you really have to.  In fact even switching out core
components like an ORM is possible and achievable if you write a little
shim and get rid of that step by step.  Better spend your time making the
system better.  The framework choice used to be a lot harder when the
systems were incompatible.  But this clearly no longer is the case.&lt;/p&gt;
&lt;p&gt;In fact, combine this with the next topic.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;building-monolithic-systems&quot;&gt;
&lt;h2&gt;Building Monolithic Systems&lt;/h2&gt;
&lt;p&gt;We are living in an agile world.  Some systems become deprecated before
they are even finished :)  In such an agile world new technologies are
introduced at such a high speed that your favorite platform might not
support it yet.&lt;/p&gt;
&lt;p&gt;As web developers we have the huge advantage that we have a nice protocol
to separate systems: it's called HTTP and the base of all we do.  Why not
leverage that even further?  Write small services that speak HTTP and
bridge them together with another application.  If that does not scale,
put a load balancer between individual components.  This has the nice side
effect that each part of the system can be implemented in a different
system.  If Python does not have the library you need or does not have the
performance: write a part of the System in Ruby/Java or whatever comes to
mind.&lt;/p&gt;
&lt;p&gt;But don't forget to still make it easy to deploy that system and put
another machine in.  If you end up with ten different programming
languages with different runtime environments you are quickly making the
life of your system administrator hell.&lt;/p&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry xml:base="http://lucumr.pocoo.org/feed.atom">
    <title type="text">Stateless and Proud in the Realtime World</title>
    <id>http://lucumr.pocoo.org/2012/8/5/stateless-and-proud</id>
    <updated>2012-08-05T00:00:00Z</updated>
    <link href="http://lucumr.pocoo.org/2012/8/5/stateless-and-proud" />
    <author>
      <name>Armin Ronacher</name>
    </author>
    <content type="html">&lt;p&gt;There is one question that comes up with Flask (and I can only suspect
Python web applications in general) more than anything else: and that is
when will we be able to do realtime applications in Flask.  The only
proper answer to this from my point of view has been: since forever.  But
not in the way you might think.&lt;/p&gt;
&lt;p&gt;I'm going to argue that the overall stateless design of modern web
frameworks is perfectly adequate even for more realtime environments.&lt;/p&gt;
&lt;div class=&quot;section&quot; id=&quot;what-is-realtime&quot;&gt;
&lt;h2&gt;What is Realtime?&lt;/h2&gt;
&lt;p&gt;Now this is where the whole problem starts.  What actually does realtime
mean.  If we keep the marketing side of things away the only difference
between realtime and not realtime in web applications is that realtime is
pushing, non realtime is polling.&lt;/p&gt;
&lt;p&gt;Let's take a concrete example where these two different paradigms are both
applicable to the same problem but in different ways.  The most basic
example here is writing a chat application where different users can talk
to each other.&lt;/p&gt;
&lt;p&gt;When the transport method is push a client sits there and waits for
messages to arrive.  If we would have a bidirectional communication
channel like TCP that's how applications used to work for a really long
time.  IRC is fundamentally just that: client A sends a message into the
TCP socket, the server receives that and forwards that message to all
other clients that share a channel with client A.  The latency for that
transmission is basically network latency + processing latency on the
server.&lt;/p&gt;
&lt;p&gt;On the other side there is HTTP.  HTTP by itself is still a two way
communication protocol but you can only send one request and get one
response.  Each request and response cycle is independent and in theory
also very stateless.  Based on those restrictions people implemented chat
systems on the web in the past by making periodic HTTP requests (for
instance once per second) to figure out if something on the server
changed.  That's the inverse of push and often referred to as polling.
I still send a message to the chat server but that one then does not
directly send it to you but stores it in a queue.  Next time the recipient
polls for new messages the queue contents are delivered and the queue is
emptied.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;avoiding-polling&quot;&gt;
&lt;h2&gt;Avoiding Polling&lt;/h2&gt;
&lt;p&gt;Now let's ignore for a time being the problem of how we build such systems
on the server and focus on the more pressing question: how can we avoid
polling in browsers?  Push based HTTP is not exactly new.  Long before web
sockets people were able to push information to browsers.  Netscape added
a server push system to their browsers a long time ago.  If you ever used
Bugzilla and did a search you will have seen this functionality in action.
Instead of the browser sitting there on the loading circle for a long time
it instead showed you the Mozilla dragon munching on bugs until the
results were ready and then the loading splash disappeared and the results
came up.  This functionality was not well supported by anything but
Mozilla browsers so it never became widespread.&lt;/p&gt;
&lt;p&gt;Another way to get information to the client in realtime is commonly named
“long polling”.  The idea is that instead of repeatedly polling the server
for results you poll it once and the server just does not reply with “no
new messages” but it waits there until a message comes up.  This has the
advantage over regular polling that you get the message with a lower
latency assuming you have a connection open (basically just the network
latency) but you can only get one message that way.  Once the result is
there you have to start the long polling process again.&lt;/p&gt;
&lt;p&gt;There are however many more ways to push information to browsers.  A
common trick was opening an iframe in the background and let the server
stream pieces of javascript that invoked callback functions with provided
JSON data.  Neat, but obviously a huge hack.&lt;/p&gt;
&lt;p&gt;And then as of lately we have websockets.  The idea behind those is that
you use HTTP only to establish a connection and then use the upgrade
functionality of HTTP to convert away from HTTP into a different TCP based
protocol.  Thanks to all the badly written HTTP proxying middleware around
this works best if you do an end to end encryption via SSL on top so that
nobody can break your communication channel.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;push-is-a-solved-problem&quot;&gt;
&lt;h2&gt;Push is a Solved Problem&lt;/h2&gt;
&lt;p&gt;Pushing information from the server to the client is as of now a solved
problem.  Depending on what browsers you want to support you might have to
provide more than one solution but at the end of the day people already
spend time on that and provided helper libraries that chose different
transport formats for you.  At first there was socket.io, now there is
SockJS and other projects that help you getting push going.&lt;/p&gt;
&lt;p&gt;Now however when you ask around in the Python web development community
you will hear voices that realtime web requires new paradigms and
frameworks and someone has to replace WSGI with a new protocol.  People
are trying to revive Twisted and cling to Tornado because it is so
asynchronous, fast and realtime.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;persistent-connections&quot;&gt;
&lt;h2&gt;Persistent Connections&lt;/h2&gt;
&lt;p&gt;Alright.  The plan is to do a push based web application.  It means we
will have to deal with persistent connections of clients.  They want to
keep the connection open for as long as possible, ideally they never
disconnect at all unless they want to.  If that standing connection is
directly exposed to your application internally I bet with you that you
will associate state with that standing connection.  What do I mean by
that?  I mean you will write code like this:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;chat_application&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;username&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;closed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;connection&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;type&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;whoami&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;username&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;data&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&amp;#39;username&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Basically when the connection is established the client sends something
into it which is then kept around until the connection is closed.  The
direct consequence of that is that even if you have a proxy for the
connection around, a code update means disconnecting all clients.  Also
one of your workers now has a standing connection to a client, you can't
relocate that connection to another worker.&lt;/p&gt;
&lt;p&gt;The more direct consequence of that code however is that it mixes badly
with traditional request/response based HTTP.  HTTP is kinda stateless.
While this paradigm is violated to some degree with the concept of cookies
you can still easily build applications where the same client can be
dispatched to different workers without breaking your application.&lt;/p&gt;
&lt;p&gt;If I browse a large website my client can be routed to different workers
for each independent request.  Many applications (and all Flask
applications by default) will even used cookies with a MAC to store your
session information so that you can pass state between independent workers
without requiring a single database operation.&lt;/p&gt;
&lt;p&gt;It seems wrong to give up on these design ideas that make HTTP powerful
just because we want to go from poll to push.  But we don't have to!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;publish-subscribe&quot;&gt;
&lt;h2&gt;Publish —&amp;nbsp;Subscribe&lt;/h2&gt;
&lt;p&gt;Now unfortunately what's happening from here onwards is something you need
to implement yourself.  Mainly because the only open source implementation
of the general concept I found was Juggernaut which happens to be no
longer maintained.  Also it was not particularly good to begin with but
that does not invalidate the concept.&lt;/p&gt;
&lt;p&gt;It's basically how we're approaching the problem at &lt;a class=&quot;reference external&quot; href=&quot;http://fireteam.net/&quot;&gt;Fireteam&lt;/a&gt; albeit not for web browsers and not for Flask.
It is however how I believe these problems should be solved.&lt;/p&gt;
&lt;p&gt;Basically we have a bunch of workers that run pretty much off-the-shelf
Python web applications.  What makes them more interesting than your
regular Flask application is that almost all requests going into the
infrastructure are separated from their HTTP request (if you're curious
about that see &lt;a class=&quot;reference external&quot; href=&quot;http://fireteam.net/blog/were-doing-http-right&quot;&gt;We're doing HTTP right&lt;/a&gt;) and only the payload
of the request is processed.  Once we know what a request does (where it's
routed, what data was transmitted with it) we're calling a function that
is responsible for providing a response and the result is then serialized
into an HTTP response again and sent to the client.&lt;/p&gt;
&lt;p&gt;Now up to that point nothing too fancy as far as the concept is concerned.
What makes it interesting however is that instead of going via HTTP it is
also possible to put the payload and some meta information onto a redis
queue instead.  The worker will pick it up like it picks up an HTTP
request but instead of making the response into an HTTP response it
publishes the result to a redis channel.&lt;/p&gt;
&lt;p&gt;See where this is going?  We're using a regular Python web application but
we can send results to something other than an HTTP response and we can
handle requests other than HTTP bound requests.&lt;/p&gt;
&lt;p&gt;Now when we do realtime we have one server that is sitting on a different
hostname and does nothing else but accepting TCP connections and keeping
them open.  There is a little bit of handshaking open so that we can
associate that connection with a specific user account and then it gets a
unique connection id.&lt;/p&gt;
&lt;p&gt;The advantages are huge for us.  Each standing connection at the core is
still very stateless unless it does not want to be.  The same rules apply
as for regular requests to the system.  We can upgrade the worker code
without closing any client's connection.&lt;/p&gt;
&lt;p&gt;Each standing connection to our server can subscribe to different
channels and there is also a private channel for a specific connection.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;realtime-in-a-nutshell&quot;&gt;
&lt;h2&gt;Realtime in a Nutshell&lt;/h2&gt;
&lt;p&gt;To make realtime work this way you end up with four separate components:&lt;/p&gt;
&lt;ul class=&quot;simple&quot;&gt;
&lt;li&gt;&lt;strong&gt;Flask&lt;/strong&gt; (or any other WSGI app if you want) would continue to work
as it does.  However there is probably also a separate way to feed
requests to that application.  In our case we're putting requests on a
queue.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;redis&lt;/strong&gt; for pubsub.  If you want biredirectional, you can also use
it as a message queue from the realtime server to the flask app.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;a realtime server&lt;/strong&gt; that maintains the standing connections and
subscribes to redis.  The messages that come from redis are then
sent to the connected clients that want them.  If you want
bidirectional communication you can also accept messages from the
clients and put them on the queue for Flask to pick up.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;a regular webserver&lt;/strong&gt; for exposing your WSGI app to the web.  This
could be nginx, Apache or whatever floats your boat.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As far as the framework is concerned nothing changes.  The only difference
is that you have a way to publish information.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;pubsub-at-the-core&quot;&gt;
&lt;h2&gt;Pubsub at the Core&lt;/h2&gt;
&lt;p&gt;Now we did not come up with that concept.  In one form or another it was
already implemented by people before.  Juggernaut, pubnub, pusher,
beaconpush and many others provide that as a webservice really.  And at
the end of the day it's really just message passing.&lt;/p&gt;
&lt;p&gt;However I have seen people respond to such suggestions in general very
negatively.  These kind of solutions are commonly seen as workarounds or
hacks.&lt;/p&gt;
&lt;p&gt;I strongly disagree with that sentiment.  I believe that a stateless
communication protocol is what makes the web great and it can be extended
to the realtime web without removing functionality.  As a side effect it
gives you a more decentralized infrastructure and a better experience
for your or connected clients when upgrading the worker code.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;section&quot; id=&quot;framework-future&quot;&gt;
&lt;h2&gt;Framework Future&lt;/h2&gt;
&lt;p&gt;I am very convinced that Python frameworks will not change much when the
people demand more realtime on the web.  They will employ pubsub designs
more and similar things, but they will not start keeping Python processes
alive for a long time that keep connections open.  At least my personal
belief is that this is the wrong way to solve the problem.&lt;/p&gt;
&lt;p&gt;Eventually I would love to make a new version of Flask that employs some
of the design principles of the Fireteam codebase in it since I believe
that is a much better way to develop remote APIs and web applications.
Until that happens though I want to share my thoughts on that topic so
that others might dive into making a reusable implementation of these
concepts instead of going down the road of making yet another Tornado.&lt;/p&gt;
&lt;/div&gt;
</content>
  </entry>
</feed>

